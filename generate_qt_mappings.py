#!/usr/bin/env python

##===--- generate_qt_mappings.py ------------------------------------------===##
#
#                     The LLVM Compiler Infrastructure
#
# This file is distributed under the University of Illinois Open Source
# License. See LICENSE.TXT for details.
#
##===----------------------------------------------------------------------===##

"""
This script generates the Qt mapping file according to given Qt include
directory

Example usage :

   $ ./generate_qt_mappings.py /usr/include/x86_64-linux-gnu/qt5 qt5_11.imp

"""

from __future__ import print_function
import argparse
import glob
import os
import re
import sys


def get_qobject_symbols():
    symbols = (
        "QObjectList",
        "qFindChildren",
        "qobject_cast",
        "QT_NO_NARROWING_CONVERSIONS_IN_CONNECT",
        "Q_CLASSINFO",
        "Q_DISABLE_COPY",
        "Q_DISABLE_COPY_MOVE",
        "Q_DISABLE_MOVE",
        "Q_EMIT",
        "Q_ENUM",
        "Q_ENUM_NS",
        "Q_FLAG",
        "Q_FLAG_NS",
        "Q_GADGET",
        "Q_INTERFACES",
        "Q_INVOKABLE",
        "Q_NAMESPACE",
        "Q_NAMESPACE_EXPORT",
        "Q_OBJECT",
        "Q_PROPERTY",
        "Q_REVISION",
        "Q_SET_OBJECT_NAME",
        "Q_SIGNAL",
        "Q_SIGNALS",
        "Q_SLOT",
        "Q_SLOTS",

        "emit",
        "slots",
        "signals",

        "SIGNAL",
        "SLOT"
    )

    symbols_map = []
    for symbol in symbols:
        symbols_map += [ ( symbol, "QObject" ) ]

    return symbols_map


def header_to_class_and_module_name(header):
    class_name = os.path.basename(header)
    module_name = os.path.basename(os.path.dirname(header))

    return class_name, module_name


def create_mapping_rules(header, class_name, module_name, symbols_map, includes_map):

    symbols_map += [ (class_name, class_name) ]

    with open(header, 'r') as f:
        content = f.read()

    includes = re.findall(r'#include "(.*)\.h"', content)
    for include in includes:
        includes_map += [ (module_name, include, class_name) ]


def main(qt_include_dir, output_file):

    symbols_map = []
    includes_map = []
    defered_headers = []


    symbols_map += get_qobject_symbols()


    headers = glob.glob(os.path.join(args.qt_include_dir, '**/*[!.h]'))
    for header in headers:
        if os.path.isdir(header):
            continue

        class_name, module_name = header_to_class_and_module_name(header)
        if class_name == module_name:
            defered_headers.append( header )
        else:
            create_mapping_rules(header, class_name, module_name, symbols_map, includes_map)


    for header in defered_headers:
        class_name, module_name = header_to_class_and_module_name(header)
        create_mapping_rules(header, class_name, module_name, symbols_map, includes_map)


    with open(args.output_file, 'w') as f:
        print("# Do not edit! This file was generated by the script %s." %
              os.path.basename(__file__), file=f)
        print("[", file=f)

        symbols_strings = []
        for symbol, header in symbols_map:
            symbols_strings += ['{ symbol: [ "%s", "private", ' % symbol
                                + '"<%s>", "public" ] }' % header]
        includes_strings = []
        for module, include, header in includes_map:
            includes_strings += [
                '{ include: [ "@[\\"<](%s/)?%s\\\\.h[\\">]", ' % (
                    module, include)
                + '"private", "<%s>", "public" ] }' % header]

        print("  %s" % ",\n  ".join(symbols_strings + includes_strings), file=f)
        print("]", file=f)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("qt_include_dir", help="Qt include directoy")
    parser.add_argument("output_file", help="Generated output mapping file")
    args = parser.parse_args()
    sys.exit(main(args.qt_include_dir, args.output_file))
